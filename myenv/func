#!/usr/bin/env bash

function cheat() {
    # Show the common usages of a command
    curl cheat.sh/$1 | less -R
}


function escape_regex() {
    # Add '\' before each special character
    local input="$1"
    echo "$input" | sed 's/[]\/$*.^[]/\\&/g'
}


function confirm_prompt() {
    # macOS sh/bash version does not support read -p
    # Print the prompt and read the user input
    echo -n "Confirm operation? (y/n): "
    read -r response

    case "$response" in
        [yY][eE][sS]|[yY])
            echo
            return 0
            ;;
        *)
            echo "Operation canceled."
            return 1
            ;;
    esac
}


function histrm() {
    # Check input parameters
    if [ $# -ne 1 ] || [ -z "$1" ]; then
        echo "Invalid input, expected exactly one parameter"
        return 1
    fi

    LC_ALL=C   # prevents 'illegal byte sequence' failure
    escaped=$(escape_regex "$1")
    deleted=$(grep "$escaped" $HISTFILE)
    count=$(echo $deleted | wc -l | xargs)  # xargs used as "strip()"

    echo
    echo "Lines:"
    echo $deleted
    echo
    echo "$count lines will be delete from $HISTFILE"
    echo

    if confirm_prompt; then
        count=$(cat $HISTFILE | wc -l | xargs)
        echo "Lines before: $count"
        sed -i '' "/$escaped/d" $HISTFILE
        count=$(cat $HISTFILE | wc -l | xargs)
        echo "Lines after: $count"
    else
        return 1
    fi
}


# Add to PATH only if not already in it
function addToPath() {
    if [[ "$PATH" != *"$1"* ]]; then
        export PATH=$PATH:$1
    fi
}

function addToPathFront() {
    if [[ "$PATH" != *"$1"* ]]; then
        export PATH=$1:$PATH
    fi
}

